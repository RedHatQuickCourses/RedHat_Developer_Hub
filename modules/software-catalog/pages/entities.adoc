#  Entities


= Entities

In the Red Hat Developer Hub, the Software Catalog serves as the central hub for discovering, managing, and understanding all the software components, services, and resources within an organization. At the heart of this catalog are *entities*.

== What are Entities?

Entities are the fundamental building blocks of the Red Hat Developer Hub's Software Catalog. They represent anything in your software ecosystem that you want to track, manage, and expose to your developers. Think of them as the digital representation of your software assets, providing a standardized way to describe and organize information about various systems, components, APIs, and resources.

Each entity is a discrete, versioned object that holds metadata and specifications about a particular item. This structured data allows the Developer Hub to render comprehensive views, build relationships between different software parts, and enable powerful search and discovery capabilities.

=== Why are Entities Important?

Entities address several key challenges in modern software development:

*   *Discovery*: Developers can easily find existing services, APIs, and components without needing to navigate complex internal documentation or ask around.
*   *Visibility*: Provides a holistic view of the software landscape, making it easier to understand dependencies and ownership.
*   *Standardization*: Enforces a consistent way of describing software assets across different teams and technologies.
*   *Governance*: Helps maintain best practices by ensuring components adhere to defined standards and lifecycle stages.
*   *Onboarding*: Accelerates the onboarding of new developers by giving them a clear map of the organization's software estate.

== Types of Entities

The Red Hat Developer Hub, based on the Backstage project, defines several standard entity *kinds* to categorize different types of software assets. Each kind has a specific purpose and structure, although they share common metadata fields.

Here are the most common entity kinds:

*   *Component*: Represents a deployable software unit, such as a microservice, a library, a website, or a mobile application. This is arguably the most frequently used entity type.
*   *API*: Describes an interface that components can interact with. This could be a REST API, GraphQL API, gRPC API, or an event-driven API.
*   *Resource*: Represents infrastructure or managed services that components rely on. Examples include databases (e.g., PostgreSQL, MongoDB), message queues (e.g., Kafka, RabbitMQ), object storage (e.g., S3 buckets), or cloud services.
*   *System*: A collection of related components and APIs that work together to deliver a larger business capability. Systems help to group related entities and provide a higher-level organizational structure.
*   *Domain*: An even higher-level grouping than `System`, representing a major functional area or business domain within an organization. A domain can contain multiple systems.
*   *User*: Represents an individual user or developer.
*   *Group*: Represents a team or collection of users. These are often used to define ownership of components.

Each entity kind helps organize the software catalog logically, allowing for a structured and searchable repository of all software assets.

== Structure of an Entity: The `catalog-info.yaml` File

Entities are defined using declarative YAML files, typically named `catalog-info.yaml`. These files are version-controlled alongside your code, ensuring that the catalog always reflects the current state of your software.

A `catalog-info.yaml` file typically contains three top-level sections:

1.  `apiVersion`: Specifies the API version of the entity schema. For most entities, this will be `backstage.io/v1alpha1`.
2.  `kind`: Defines the type of entity, such as `Component`, `API`, `Resource`, `System`, etc.
3.  `metadata`: Contains general information about the entity, including:
    *   `name`: A unique identifier for the entity (must be URL-friendly).
    *   `title`: A human-readable name for the entity, often used in UI.
    *   `description`: A brief summary of what the entity is.
    *   `annotations`: Key-value pairs for additional metadata, often used for integrations or specific tooling (e.g., `github.com/project-slug`, `backstage.io/techdocs-ref`).
    *   `labels`: Simple key-value pairs for categorization and filtering.
4.  `spec`: Holds the specific configuration and properties for the entity, which vary depending on its `kind`. For example, a `Component` might have `type`, `lifecycle`, `owner`, and `dependsOn` fields, while an `API` might have `type` and `definition` fields.

Let's look at a basic example for a `Component`:

[source,yaml]
----
apiVersion: backstage.io/v1alpha1
kind: Component
metadata:
  name: my-first-service
  title: My First Microservice
  description: A sample Spring Boot microservice for user management.
  annotations:
    github.com/project-slug: your-org/my-first-service # Link to your GitHub repo
    backstage.io/techdocs-ref: dir:. # Where to find TechDocs documentation
  labels:
    tier: backend
    language: java
spec:
  type: service
  lifecycle: development
  owner: team-a
  system: user-management-system
  # relations:
  #   - type: providesApi
  #     targetRef: api:user-api
  #   - type: consumesApi
  #     targetRef: api:database-connector-api
----

In this example:

*   `kind: Component` indicates this YAML describes a software component.
*   `name: my-first-service` is its unique identifier.
*   `owner: team-a` specifies the team responsible for it.
*   `system: user-management-system` links it to a larger system.
*   `annotations` provide links to its source code and documentation.

== Hands-on Activity: Defining Your First Entity

In this activity, you will create a `catalog-info.yaml` file for a hypothetical microservice. This exercise will help you understand the core structure and fields of an entity definition.

.Prerequisites
*   A text editor or IDE (e.g., VS Code, Sublime Text, Vim).
*   Basic understanding of YAML syntax.

.Steps
.  *Create a new directory* for your entity definition.
    For example, you can create a directory named `my-first-entity`.
+
[source,bash]
----
mkdir my-first-entity
cd my-first-entity
----

.  *Create the `catalog-info.yaml` file*.
    Open your text editor and create a new file named `catalog-info.yaml` inside the `my-first-entity` directory.

.  *Add the basic entity structure*.
    Copy and paste the following content into your `catalog-info.yaml` file. This defines a `Component` entity for a hypothetical `product-catalog-service`.
+
[source,yaml]
----
apiVersion: backstage.io/v1alpha1
kind: Component
metadata:
  name: product-catalog-service
  title: Product Catalog Service
  description: A microservice responsible for managing product information and inventory.
  annotations:
    github.com/project-slug: my-org/product-catalog-service
    backstage.io/techdocs-ref: dir:.
  labels:
    tier: backend
    language: go
spec:
  type: service
  lifecycle: production
  owner: team-products
  system: e-commerce-platform
----

.  *Review and understand the fields*:
    *   `apiVersion`: `backstage.io/v1alpha1` - Standard API version for Backstage entities.
    *   `kind`: `Component` - This entity describes a deployable software component.
    *   `metadata.name`: `product-catalog-service` - The unique identifier for this component.
    *   `metadata.title`: `Product Catalog Service` - A more user-friendly name displayed in the UI.
    *   `metadata.description`: Explains the service's purpose.
    *   `metadata.annotations`:
        *   `github.com/project-slug`: Points to the GitHub repository where the service's code resides.
        *   `backstage.io/techdocs-ref`: Indicates where the technical documentation for this service can be found (in this case, in the current directory of the repo).
    *   `metadata.labels`: Key-value pairs for tagging and categorization (`tier: backend`, `language: go`).
    *   `spec.type`: `service` - Further specifies the kind of component.
    *   `spec.lifecycle`: `production` - Indicates the current stage of the service's lifecycle.
    *   `spec.owner`: `team-products` - Assigns ownership to a specific team (which would also be an entity of kind `Group`).
    *   `spec.system`: `e-commerce-platform` - Links this service to a larger system within the organization.

.  *Save the file*.
    Save your changes to `catalog-info.yaml`.

This `catalog-info.yaml` file now defines your first entity. In a real Red Hat Developer Hub setup, you would then register this file with the Developer Hub's Software Catalog to make it discoverable and manageable.

TIP: While this exercise focuses on a `Component` entity, you can define other entity kinds (like `API` or `Resource`) by changing the `kind` field and adjusting the `spec` accordingly to match the schema for that specific kind. You can find comprehensive schema documentation on the Backstage website, which applies directly to Red Hat Developer Hub.